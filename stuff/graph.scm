(define (transpose m)
  (if (null? (car m))
      '()
      (cons (map car m)
        (transpose (map cdr m)))))

(define (cartesian-product L1 L2)
  (define m (length L1))
  (define n (length L2))
  (define (helper1 i j)
    (if (= i n)
        '()
        (cons (cons (list-ref L1 j) 
                    (list (list-ref L2 i)))
              (helper1 (+ i 1) j))))
  (define (helper2 j)
    (if (= j m)
        '()
        (append (helper1 0 j)
              (helper2 (+ j 1)))))
  (helper2 0))

(define (flatten L)
  (cond ((null? L) '())
        ((not (list? (car L)))
          (cons (car L) 
                (flatten (cdr L))))
        (else (append (flatten (car L)) 
                      (flatten (cdr L))))))


;-------------------------------------------------------------------------------------------------------

(define G '((3 5) (4 5) (5 3 4 8) (8 5)))
(define (vertices g) (map car g))
(define (neighbours v g) (cdr (assoc v g)))
(define (create-graph vertices)
  (map list vertices))
(define (add-vertex! v g)
  (set-cdr! g (cons (list v) (cdr g))))
(define (add-edge! start end g)
  (let ((start-vertex (assoc start g)))
    (set-cdr! start-vertex (cons end (cdr start-vertex)))))

(define (degree v g)
  (define (degree-out)
    (length (neighbours v g)))
  (define (degree-in)
    (apply + (map (lambda (L)
                    (if (list? (memv v (cdr L)))
                        1
                        0))
                  g)))
  (+ (degree-out) (degree-in)))

(define (edges g)
  (apply append
         (map (lambda (L)
                (if (null? (cdr L))
                    '()
                    (map (lambda (li)
                           (cons (car L) (list li)))
                         (cdr L))))
              g)))

(define (symmetric? g)
  (let ((edges (edges g))
        (len (length g)))
    (define (helper i)
      (if (= i (- len 1))
          #t
          (let* ((current-edge (list-ref edges i))
                 (symm-edge
                  (append (cdr current-edge)
                          (list (car current-edge)))))
            (if (not (list? (member symm-edge edges)))
                #f
                (helper (+ i 1))))))
    (helper 0)))

(define (invert g)
  (let* ((vertices (vertices g))
         (G1 (create-graph vertices))
         (len (length vertices)))
    (define (helper i)
      (if (= i len)
          G1
          (let* ((neighbours (neighbours (list-ref vertices i) g))
                  (len2 (length neighbours)))
            (define (helper2 j)
              (if (= j len2)
                  (helper (+ i 1))
                  (begin (add-edge! (list-ref neighbours j) (list-ref vertices i) G1)
                         (helper2 (+ j 1)))))
            (helper2 0))))
    (helper 0)))