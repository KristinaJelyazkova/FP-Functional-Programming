; Събира числа :)
(define (add a b)
  (+ a b))

; Определя дали дадено число е нечетно.
(define (my-odd? a)
  (if (= (remainder a 2) 1)
    #t
    #f))

; Опростен вариант на горното решение - директно връщаме стойността на булевия израз.
(define (my-even? a)
  (= (remainder a 2) 0))

(assert-true (my-odd? 3))
(assert-false (my-odd? 4))
(assert-false (my-even? 1))
(assert-true (my-even? 2))

; Връща -1, 0 или 1 в зависимост от това дали числото е отрицателно, нула или положително.
(define (signum1 n)
  (if (> n 0)
    1
    (if (< n 0)
      -1
      0)))

; Същото като горното, но направено с cond.
; Препоръчвам ви да ползвате cond, когато е възможно.
(define (signum2 n)
  (cond
    ((> n 0) 1)
    ((< n 0) -1)
    (else 0)))

; Изчислява факториел.
; Забележете сходството на решението с математическата дефиниция на факториел.
(define (fact n)
  (if (<= n 1)
      1
      (* n (fact (- n 1)))))

; Сумира числата в даден интервал.
; start последователно обхожда целия интервал.
(define (sum start end)
  (if (>= start end)
      end
      (+ start (sum (+ start 1) end))))

; Вдига x на степен n.
; Подобно е на вградената функция expt.
(define (pow x n)
  (if (= 0 n)
      1
      (* x (pow x (- n 1)))))

(define (square x) (* x x))

; Бързо степенуване.
; Работи като нормалното, като единствената разлика е оптимизацията при четни n.
(define (fastpow x n)
  (cond
    ((= n 0) 1)
    ; Викаме помощната процедура за вдигане на квадрат, защото нещо такова:
    ; (* (fastpow x (/n 2)) (fastpow x (/ n 2)))
    ; Би направило две извиквания към fastpow, от които няма смисъл.
    ; Вместо fastpow2 може да се ползва и вградената процедура за степенуване - expt.
    ((even? n) (square (fastpow x (/ n 2))))
    (else (* x (fastpow x (- n 1))))))
